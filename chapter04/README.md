# Chapter 04. 클래스와 인터페이스

추상화의 기본 단위인 클래스와 인터페이스는 자바 언의 심장과도 같다. 
클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만드는 방법

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

프로그램의 요소와 접근성은 가능한 한 최소한으로 하라. 
꼭 필요한 것만 골라 최소한의 public API 를 설계하자. 
그 외에는 클래스, 인터페이스, 멤버가 의도치않게 API로 공개되는 일이 없도록 해야한다. 

잘 설계된 컴포넌트는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다. 
잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API 를 깔끔히 분리한다. 

### 캡슐화의 장점
- 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발 가능
- 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문이다. 
- 성능 최적화에 도움을 준다. 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 가능
- 소프트웨어 재사용성을 높인다. 
- 큰 시스템을 제작하는 난이도를 낮춘다. 

### 접근제어자
자바는 접근제한자를 활용해서 정보 은닉을 달성할 수 있다. 
- `private` : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다. 
- `package-private`: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 접근제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다. 
- `protected`: package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다. [[JLS, 6.6.2](https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.6.2)]
- `public`: 모든 곳에서 접근할 수 있다. 

### 원칙
#### 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다. 
- 한 클래스에서만 사용하는 클래스나 인터페이스는 이를 사용하는 클래스 안에 private static 으로 중첩시킬 수 있다. 
- public 일 필요가 없는 클래스의 접근 수준을 package-private 톱레벨 클래스로 좁히는 것이 중요하다. 

### 주의사항
- 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위클래스에서보다 좁게 설정할 수 없다[[JLS, 8.4.9.3](https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.8.3)]
  - 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프 치환 원칙)을 지키기 위해 필요하다
- 코드를 테스트하려는 목적으로 접근범위를 넓힐 수도 있다. private 멤버를 package-private 까지 풀어주는 것은 허용할 수 있지만, 그 이상은 안 된다. 
- public 클래스의 인스턴스 필드는 되도록 public 이 아니어야 한다. 
- public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다. 
- 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.
  - public 배열을 private로 만들고, public 불변 리스트를 추가하거나,
  - 배열을 private로 만들고 그 복사본을 반환하는 pulbic 메서드를 추가함으로써 해결할 수 있다. 
  
### 자바9에 추가된 내용
- 자바 9에서는 모듈 시스템이라는 개념이 도입되면서 두 가지 암묵적 접근 수준이 추가되었다. 
  - 모듈은 자신이 속하는 패키지 중 공개(export) 할 것들을 (관례상 module-info.java 파일에) 선언한다. protected 혹은 public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서는 접근할 수 없다. 
  - 숨겨진 패키지 안에 있는 public 클래스의 public, protected 멤버에 암묵적 접근 수준이 적용된다. 각각 public, protected 수준과 같으나, 그 효과가 모듈 내부로 한정된다. 
- 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다. 
- 주의해야 할 점
  - 모듈의 jar 파일을 자신의 모듈 경로가 아닌 애플리케이션의 클래스패스(classpath)에 두면 그 모듈 안의 모든 패키지는 마치 모듈이 없는 것 처럼 행동한다..
  - 모듈의 장점을 누리려면 해야할 일이 많다. 
- 꼭 필요한 경우가 아니라면 당분간은 사용하지 않는 게 좋을 것 같다. 

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

코드 16-1 퇴보한 클래스는 public 이어서는 안 된다. 
```
class Point {
    public double x;
    public double y;
}
```

코드 16-2 접근자와 변경자(mutator) 메서드를 활용해 데이터를 캡슐화한다. 
```
class Point {
    private double x;
    private double y;

    public Point(double x, double y); {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }
    
    public void setX(double x) {
        this.x = x;
    }
    public void setY(double y) {
        this.y = y;
    }
}
```

패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다. 
package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다. 

public 클래스의 필드가 불변이라면 직접 노출할때의 단점이 조금은 줄어들지만, 여전히 결코 좋은 생각이 아니다. 
단 불변식은 보장할 수 있게 된다.

코드 16-3 불변 필드를 노출한 public 클래스 - 과연 좋은가?
```
public final class Time {
    private static final int HOURS_PER_DAY = 24;
    private static final int MINUTES_PER_HOUR = 60;

    public final int hour;
    public final int minute;

    public Time(int hour, int minute) {
        if (hour < 0 || hour >= HOURS_PER_DAY) {
            throw new IllegalArgumentException("시간: " + hour);
        }
        if (minute < 0 || minute >= MINUTES_PER_HOUR) {
            throw new IllegalArgumentException("분: " + minute);
        }
        this.hour = hour;
        this.minute = minute;
    }
}
```


## 아이템 17. 변경 가능성을 최소화하라

### 정의
불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스다. 
불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다. 

### 특징
불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다. 

### 불변 객체를 만들 때 
- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다 
- 클래스를 확장할 수 없도록 한다
- 모든 필드를 final로 선언한다
- 모든 필드를 private로 선언한다
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다 (방어적 복사를 수행하라)

### 불변객체의 장점
- 불변 객체는 단순하다
    - 모든 생성자가 클래스의 불변식(class invariant)을 보장한다면 그 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않더라도 영원히 불변으로 남는다
- 불변객체는 근본적으로 스레드 안전하여 따로 동기화 할 필요가 없다. 
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. 
- 불변 객체는 그 자체로 실패 원자성을 제공한다. 
    - 상태가 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다. 

### 불변객체의 단점
잠재적 성능 저하

### 주의점
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자
- 다른 합당한 이유가 없다면 모든 필드는 private final 이어야 한다
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완전히 끝난 상태의 객체를 생성해야 한다. 


## 아이템 18. 상속보다는 컴포지션을 사용하라

### 상속이 좋은 경우
상위클래스와 하위클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전한 방법이다. 
확장할 목적으로 설계되었고 문서화도 잘 된 클래스도 마찬가지로 안전하다. 

### 상속이 좋지 않은 경우
- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다
    - HashSet addAll 은 내부적으로 add 를 사용해 구현되어 있음
    - 자신의 다른 부분을 사용하는 '자기사용(self-use)' 여부는 해당 클래스의 내부 구현 방식에 해당하며, 자바 플랫폼 전반적인 정책인지, 그래서 다음 릴리스에서도 유지될지는 알 수 없다

### 대안
- 기존 클래스를 확장(extend)하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하자. 
- 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션(composition; 구성)이라 한다. 


컴포지션과 전달의 조합은 넓은 의미로 위임(delegation)이라고 부른다. 
엄밀히 따지면 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위임에 해당한다. 

### 단점
- 래퍼 클래스가 콜백(callback) 프레임워크와는 어울리지 않는다 (SELF 문제)

### 정리
- 상속은 강력하지만 캡슐화를 해친다는 문제가 있다. 
- 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다. 
- is-a 관계일 때도 안심할 수만은 없는 게, 하위 클래스의 패키지가 상위 클래스와 다르고, 상위클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다. 
- 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자. 
- 특히 래퍼클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다. 래퍼 클래스는 하위 클래스보다 견고하고 강력하다. 
